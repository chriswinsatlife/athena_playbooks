# d3-shape
Visualizations can be represented by discrete graphical marks such as symbols, arcs, lines, and areas. While the rectangles of a bar chart may sometimes be simple, other shapes are complex, such as rounded annular sectors and Catmull–Rom splines. The d3-shape module provides a variety of shape generators for your convenience.

As with other aspects of D3, these shapes are driven by data: each shape generator exposes accessors that control how the input data are mapped to a visual representation. For example, you might define a line generator for a time series by scaling fields of your data to fit the chart:

js
const line = d3.line()
    .x((d) => x(d.date))
    .y((d) => y(d.value));
This line generator can then be used to compute the d attribute of an SVG path element:

js
path.datum(data).attr("d", line);
Or you can use it to render to a Canvas 2D context:

js
line.context(context)(data);
See one of:

Arcs - circular or annular sectors, as in a pie or donut chart.
Areas - an area defined by a bounding topline and baseline, as in an area chart.
Curves - interpolate between points to produce a continuous shape.
Lines - a spline or polyline, as in a line chart.
Links - a smooth cubic Bézier curve from a source to a target.
Pies - compute angles for a pie or donut chart.
Stacks - stack adjacent shapes, as in a stacked bar chart.
Symbols - a categorical shape encoding, as in a scatterplot.
Radial areas - like area, but in polar coordinates.
Radial lines - like line, but in polar coordinates.
Radial links - like link, but in polar coordinates.

---

## Arcs
The arc generator produces a circular or annular sector, as in a pie or donut chart. Arcs are centered at the origin; use a transform to move the arc to a different position.

js
svg.append("path")
    .attr("transform", "translate(100,100)")
    .attr("d", d3.arc()({
      innerRadius: 100,
      outerRadius: 200,
      startAngle: -Math.PI / 2,
      endAngle: Math.PI / 2
    }));
If the absolute difference between the start and end angles (the angular span) is greater than 2π, the arc generator will produce a complete circle or annulus. If it is less than 2π, the arc’s angular length will be equal to the absolute difference between the two angles (going clockwise if the signed difference is positive and anticlockwise if it is negative). If the absolute difference is less than 2π, the arc may have rounded corners and angular padding.

See also the pie generator, which computes the necessary angles to represent an array of data as a pie or donut chart; these angles can then be passed to an arc generator.

arc()
Source · Constructs a new arc generator with the default settings. With default settings:

js
const arc = d3.arc();
Or, with the radii and angles configured as constants:

js
const arc = d3.arc()
    .innerRadius(0)
    .outerRadius(100)
    .startAngle(0)
    .endAngle(Math.PI / 2);
arc(...arguments)
Source · Generates an arc for the given arguments. The arguments are arbitrary; they are propagated to the arc generator’s accessor functions along with the this object. For example, with the default settings, an object with radii and angles is expected:

js
const arc = d3.arc();

arc({
  innerRadius: 0,
  outerRadius: 100,
  startAngle: 0,
  endAngle: Math.PI / 2
}); // "M0,-100A100,100,0,0,1,100,0L0,0Z"
If the radii and angles are instead defined as constants, you can generate an arc without any arguments:

js
d3.arc()
    .innerRadius(0)
    .outerRadius(100)
    .startAngle(0)
    .endAngle(Math.PI / 2)
  (); // "M0,-100A100,100,0,0,1,100,0L0,0Z"
If the arc generator has a context, then the arc is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.

arc.centroid(...arguments)
Examples · Source · Computes the midpoint [x, y] of the center line of the arc that would be generated by the given arguments.

The arguments are arbitrary; they are propagated to the arc generator’s accessor functions along with the this object. To be consistent with the generated arc, the accessors must be deterministic, i.e., return the same value given the same arguments. The midpoint is defined as (startAngle + endAngle) / 2 and (innerRadius + outerRadius) / 2. For example:

Note that this is not the geometric center of the arc, which may be outside the arc; this method is merely a convenience for positioning labels.

arc.innerRadius(radius)
Source · If radius is specified, sets the inner radius to the specified function or number and returns this arc generator.

js
const arc = d3.arc().innerRadius(40);
If radius is not specified, returns the current inner radius accessor.

js
arc.innerRadius() // () => 40
The inner radius accessor defaults to:

js
function innerRadius(d) {
  return d.innerRadius;
}
Specifying the inner radius as a function is useful for constructing a stacked polar bar chart, often in conjunction with a sqrt scale. More commonly, a constant inner radius is used for a donut or pie chart. If the outer radius is smaller than the inner radius, the inner and outer radii are swapped. A negative value is treated as zero.

arc.outerRadius(radius)
Source · If radius is specified, sets the outer radius to the specified function or number and returns this arc generator.

js
const arc = d3.arc().outerRadius(240);
If radius is not specified, returns the current outer radius accessor.

js
arc.outerRadius() // () => 240
The outer radius accessor defaults to:

js
function outerRadius(d) {
  return d.outerRadius;
}
Specifying the outer radius as a function is useful for constructing a coxcomb or polar bar chart, often in conjunction with a sqrt scale. More commonly, a constant outer radius is used for a pie or donut chart. If the outer radius is smaller than the inner radius, the inner and outer radii are swapped. A negative value is treated as zero.

arc.cornerRadius(radius)
Corner radius:

18

Examples · Source · If radius is specified, sets the corner radius to the specified function or number and returns this arc generator.

js
const arc = d3.arc().cornerRadius(18);
If radius is not specified, returns the current corner radius accessor.

js
arc.cornerRadius() // () => 18
The corner radius accessor defaults to:

js
function cornerRadius() {
  return 0;
}
If the corner radius is greater than zero, the corners of the arc are rounded using circles of the given radius. For a circular sector, the two outer corners are rounded; for an annular sector, all four corners are rounded.

The corner radius may not be larger than (outerRadius - innerRadius) / 2. In addition, for arcs whose angular span is less than π, the corner radius may be reduced as two adjacent rounded corners intersect. This occurs more often with the inner corners. See the arc corners animation for illustration.

arc.startAngle(angle)
Source · If angle is specified, sets the start angle to the specified function or number and returns this arc generator.

js
const arc = d3.arc().startAngle(Math.PI / 4);
If angle is not specified, returns the current start angle accessor.

js
arc.startAngle() // () => 0.7853981633974483
The start angle accessor defaults to:

js
function startAngle(d) {
  return d.startAngle;
}
The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise. If |endAngle - startAngle| ≥ 2π, a complete circle or annulus is generated rather than a sector.

arc.endAngle(angle)
Source · If angle is specified, sets the end angle to the specified function or number and returns this arc generator.

js
const arc = d3.arc().endAngle(Math.PI);
If angle is not specified, returns the current end angle accessor.

js
arc.endAngle() // () => 3.141592653589793
The end angle accessor defaults to:

js
function endAngle(d) {
  return d.endAngle;
}
The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise. If |endAngle - startAngle| ≥ 2π, a complete circle or annulus is generated rather than a sector.

arc.padAngle(angle)
Pad angle:

0.030

Examples · Source · If angle is specified, sets the pad angle to the specified function or number and returns this arc generator.

js
const arc = d3.arc().padAngle(0);
If angle is not specified, returns the current pad angle accessor.

js
arc.padAngle() // () => 0
The pad angle accessor defaults to:

js
function padAngle() {
  return d && d.padAngle;
}
The pad angle is converted to a fixed linear distance separating adjacent arcs, defined as padRadius × padAngle. This distance is subtracted equally from the start and end of the arc. If the arc forms a complete circle or annulus, as when |endAngle - startAngle| ≥ 2π, the pad angle is ignored.

If the inner radius or angular span is small relative to the pad angle, it may not be possible to maintain parallel edges between adjacent arcs. In this case, the inner edge of the arc may collapse to a point, similar to a circular sector. For this reason, padding is typically only applied to annular sectors (i.e., when innerRadius is positive), as shown in this diagram:

The recommended minimum inner radius when using padding is outerRadius * padAngle / sin(θ), where θ is the angular span of the smallest arc before padding. For example, if the outer radius is 200 pixels and the pad angle is 0.02 radians, a reasonable θ is 0.04 radians, and a reasonable inner radius is 100 pixels. See the arc padding animation for illustration.

Often, the pad angle is not set directly on the arc generator, but is instead computed by the pie generator so as to ensure that the area of padded arcs is proportional to their value; see pie.padAngle. See the pie padding animation for illustration. If you apply a constant pad angle to the arc generator directly, it tends to subtract disproportionately from smaller arcs, introducing distortion.

arc.padRadius(radius)
Pad radius:

200

Source · If radius is specified, sets the pad radius to the specified function or number and returns this arc generator. If radius is not specified, returns the current pad radius accessor, which defaults to null, indicating that the pad radius should be automatically computed as sqrt(innerRadius × innerRadius + outerRadius × outerRadius). The pad radius determines the fixed linear distance separating adjacent arcs, defined as padRadius × padAngle.

arc.context(context)
Source · If context is specified, sets the context and returns this arc generator.

js
const context = canvas.getContext("2d");
const arc = d3.arc().context(context);
If context is not specified, returns the current context, which defaults to null.

js
arc.context() // context
If the context is not null, then the generated arc is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated arc is returned.

arc.digits(digits)
Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this arc generator.

js
const arc = d3.arc().digits(3);
If digits is not specified, returns the current maximum fraction digits, which defaults to 3.

js
arc.digits() // 3
This option only applies when the associated context is null, as when this arc generator is used to produce path data.

---

## Areas

Areas
Examples · The area generator produces an area defined by a topline and a baseline as in an area chart. Typically, the two lines share the same x-values (x0 = x1), differing only in y-value (y0 and y1); most commonly, y0 is defined as a constant representing zero (the y scale’s output for zero). The topline is defined by x1 and y1 and is rendered first; the baseline is defined by x0 and y0 and is rendered second with the points in reverse order. With a curveLinear curve, this produces a clockwise polygon. See also radial areas.

area(x, y0, y1)
Source · Constructs a new area generator with the given x, y0, and y1 accessors or numbers.

js
const area = d3.area((d) => x(d.Date), y(0), (d) => y(d.Close));
If x, y0 or y1 are not specified, the respective defaults will be used. The above can be expressed more explicitly as:

js
const area = d3.area()
    .x((d) => x(d.Date))
    .y0(y(0))
    .y1((d) => y(d.Close));
area(data)
Source · Generates an area for the given array of data.

js
svg.append("path").attr("d", area(data));
If the area generator has a context, then the area is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.

CAUTION

Depending on this area generator’s associated curve, the given input data may need to be sorted by x-value before being passed to the area generator.

area.x(x)
Source · If x is specified, sets x0 to x and x1 to null and returns this area generator.

js
const area = d3.area().x((d) => x(d.Date));
If x is not specified, returns the current x0 accessor.

js
area.x() // (d) => x(d.Date)
area.x0(x)
TIP

This method is intended for vertically-oriented areas, as when time goes down↓ rather than right→; for the more common horizontally-oriented areas, use area.x instead.

Source · If x is specified, sets the x0 accessor to the specified function or number and returns this area generator.

js
const area = d3.area().x0(x(0));
When an area is generated, the x0 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.

If x is not specified, returns the current x0 accessor.

js
area.x0() // () => 20
The x0 accessor defaults to:

js
function x(d) {
  return d[0];
}
The default x0 accessor assumes that the input data are two-element arrays of numbers [[x0, y0], [x1, y1], …]. If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor as shown above.

area.x1(x)
TIP

This method is intended for vertically-oriented areas, as when time goes down↓ rather than right→; for the more common horizontally-oriented areas, use area.x instead.

Source · If x is specified, sets the x1 accessor to the specified function or number and returns this area generator.

js
const area = d3.area().x1((d) => x(d.Close));
When an area is generated, the x1 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.

If x is not specified, returns the current x1 accessor.

js
area.x1() // (d) => x(d.Close)
The x1 accessor defaults to null, indicating that the previously-computed x0 value should be reused for the x1 value; this default is intended for horizontally-oriented areas.

area.y(y)
TIP

This method is intended for vertically-oriented areas, as when time goes down↓ rather than right→; for the more common horizontally-oriented areas, use area.y0 and area.y1 instead.

Source · If y is specified, sets y0 to y and y1 to null and returns this area generator.

js
const area = d3.area().y((d) => y(d.Date));
If y is not specified, returns the current y0 accessor.

js
area.y() // (d) => y(d.Date)
area.y0(y)
Source · If y is specified, sets the y0 accessor to the specified function or number and returns this area generator.

js
const area = d3.area().y0(y(0));
When an area is generated, the y0 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments. For a horizontally-oriented area with a constant baseline (i.e., an area that is not stacked, and not a ribbon or band), y0 is typically set to the output of the y scale for zero.

If y is not specified, returns the current y0 accessor.

js
area.y0() // () => 360
The y0 accessor defaults to:

js
function y() {
  return 0;
}
In the default SVG coordinate system, note that the default zero represents the top of the chart rather than the bottom, producing a flipped (or “hanging”) area.

area.y1(y)
Source · If y is specified, sets the y1 accessor to the specified function or number and returns this area generator.

js
const area = d3.area().y1((d) => y(d.Close));
When an area is generated, the y1 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.

If y is not specified, returns the current y1 accessor.

js
area.y1() // (d) => y(d.Close)
The y1 accessor defaults to:

js
function y(d) {
  return d[1];
}
The default y1 accessor assumes that the input data are two-element arrays of numbers [[x0, y0], [x1, y1], …]. If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor as shown above. A null accessor is also allowed, indicating that the previously-computed y0 value should be reused for the y1 value; this can be used for a vertically-oriented area, as when time goes down↓ instead of right→.

area.defined(defined)
Examples · Source · If defined is specified, sets the defined accessor to the specified function or boolean and returns this area generator.

js
const area = d3.area().defined((d) => !isNaN(d.Close));
When an area is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments. If the given element is defined (i.e., if the defined accessor returns a truthy value for this element), the x0, x1, y0 and y1 accessors will subsequently be evaluated and the point will be added to the current area segment. Otherwise, the element will be skipped, the current area segment will be ended, and a new area segment will be generated for the next defined point. As a result, the generated area may have several discrete segments.

If defined is not specified, returns the current defined accessor.

js
area.defined() // (d) => !isNaN(d.Close)
The defined accessor defaults to the constant true, and assumes that the input data is always defined:

js
function defined() {
  return true;
}
Note that if an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps. In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.

area.curve(curve)
Source · If curve is specified, sets the curve factory and returns this area generator.

js
const area = d3.area().curve(d3.curveStep);
If curve is not specified, returns the current curve factory, which defaults to curveLinear.

js
area.curve() // d3.curveStep
area.context(context)
Source · If context is specified, sets the context and returns this area generator.

js
const context = canvas.getContext("2d");
const area = d3.area().context(context);
If context is not specified, returns the current context.

js
area.context() // context
The context defaults to null. If the context is not null, then the generated area is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated area is returned.

area.digits(digits)
Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this area generator.

js
const area = d3.area().digits(3);
If digits is not specified, returns the current maximum fraction digits, which defaults to 3.

js
area.digits() // 3
This option only applies when the associated context is null, as when this area generator is used to produce path data.

area.lineX0()
An alias for area.lineY0.

area.lineY0()
Source · Returns a new line generator that has this area generator’s current defined accessor, curve and context. The line’s x-accessor is this area’s x0-accessor, and the line’s y-accessor is this area’s y0-accessor.

area.lineX1()
Source · Returns a new line generator that has this area generator’s current defined accessor, curve and context. The line’s x-accessor is this area’s x1-accessor, and the line’s y-accessor is this area’s y0-accessor.

area.lineY1()
Source · Returns a new line generator that has this area generator’s current defined accessor, curve and context. The line’s x-accessor is this area’s x0-accessor, and the line’s y-accessor is this area’s y1-accessor.

---

## Curves

Curves
Curves turn a discrete (pointwise) representation of a line or area into a continuous shape: curves specify how to interpolate between two-dimensional [x, y] points.

Curves are typically not constructed or used directly. Instead, one of the built-in curves is being passed to line.curve or area.curve.

js
const line = d3.line()
    .x((d) => x(d.date))
    .y((d) => y(d.value))
    .curve(d3.curveCatmullRom.alpha(0.5));
If desired, you can implement a custom curve. For an example of using a curve directly, see Context to Curve.

curveBasis(context)
Source · Produces a cubic basis spline using the specified control points. The first and last points are triplicated such that the spline starts at the first point and ends at the last point, and is tangent to the line between the first and second points, and to the line between the penultimate and last points.

curveBasisClosed(context)
Source · Produces a closed cubic basis spline using the specified control points. When a line segment ends, the first three control points are repeated, producing a closed loop with C2 continuity.

curveBasisOpen(context)
Source · Produces a cubic basis spline using the specified control points. Unlike basis, the first and last points are not repeated, and thus the curve typically does not intersect these points.

curveBumpX(context)
Source · Produces a Bézier curve between each pair of points, with horizontal tangents at each point.

curveBumpY(context)
Source · Produces a Bézier curve between each pair of points, with vertical tangents at each point.

curveBundle(context)
0.0
0.2
0.4
0.6
0.8
1.0
beta
Source · Produces a straightened cubic basis spline using the specified control points, with the spline straightened according to the curve’s beta, which defaults to 0.85. This curve is typically used in hierarchical edge bundling to disambiguate connections, as proposed by Danny Holten in Hierarchical Edge Bundles: Visualization of Adjacency Relations in Hierarchical Data. This curve does not implement curve.areaStart and curve.areaEnd; it is intended to work with d3.line, not d3.area.

curveBundle.beta(beta)
Beta:

0.85

Source · Returns a bundle curve with the specified beta in the range [0, 1], representing the bundle strength. If beta equals zero, a straight line between the first and last point is produced; if beta equals one, a standard basis spline is produced. For example:

js
const line = d3.line().curve(d3.curveBundle.beta(0.5));
curveCardinal(context)
0.0
0.2
0.4
0.6
0.8
1.0
tension
Source · Produces a cubic cardinal spline using the specified control points, with one-sided differences used for the first and last piece. The default tension is 0.

curveCardinalClosed(context)
0.0
0.2
0.4
0.6
0.8
1.0
tension
Source · Produces a closed cubic cardinal spline using the specified control points. When a line segment ends, the first three control points are repeated, producing a closed loop. The default tension is 0.

curveCardinalOpen(context)
0.0
0.2
0.4
0.6
0.8
1.0
tension
Source · Produces a cubic cardinal spline using the specified control points. Unlike curveCardinal, one-sided differences are not used for the first and last piece, and thus the curve starts at the second point and ends at the penultimate point. The default tension is 0.

curveCardinal.tension(tension)
Tension:

0.00

Source · Returns a cardinal curve with the specified tension in the range [0, 1]. The tension determines the length of the tangents: a tension of one yields all zero tangents, equivalent to curveLinear; a tension of zero produces a uniform Catmull–Rom spline. For example:

js
const line = d3.line().curve(d3.curveCardinal.tension(0.5));
curveCatmullRom(context)
0.0
0.2
0.4
0.6
0.8
1.0
alpha
Source · Produces a cubic Catmull–Rom spline using the specified control points and the parameter alpha, which defaults to 0.5, as proposed by Yuksel et al. in On the Parameterization of Catmull–Rom Curves, with one-sided differences used for the first and last piece.

curveCatmullRomClosed(context)
0.0
0.2
0.4
0.6
0.8
1.0
alpha
Source · Produces a closed cubic Catmull–Rom spline using the specified control points and the parameter alpha, which defaults to 0.5, as proposed by Yuksel et al. When a line segment ends, the first three control points are repeated, producing a closed loop.

curveCatmullRomOpen(context)
0.0
0.2
0.4
0.6
0.8
1.0
alpha
Source · Produces a cubic Catmull–Rom spline using the specified control points and the parameter alpha, which defaults to 0.5, as proposed by Yuksel et al. Unlike curveCatmullRom, one-sided differences are not used for the first and last piece, and thus the curve starts at the second point and ends at the penultimate point.

curveCatmullRom.alpha(alpha)
Alpha:

0.50

Source · Returns a cubic Catmull–Rom curve with the specified alpha in the range [0, 1]. If alpha is zero, produces a uniform spline, equivalent to curveCardinal with a tension of zero; if alpha is one, produces a chordal spline; if alpha is 0.5, produces a centripetal spline. Centripetal splines are recommended to avoid self-intersections and overshoot. For example:

js
const line = d3.line().curve(d3.curveCatmullRom.alpha(0.5));
curveLinear(context)
Source · Produces a polyline through the specified points.

curveLinearClosed(context)
Source · Produces a closed polyline through the specified points by repeating the first point when the line segment ends.

curveMonotoneX(context)
Source · Produces a cubic spline that preserves monotonicity in y, assuming monotonicity in x, as proposed by Steffen in A simple method for monotonic interpolation in one dimension: “a smooth curve with continuous first-order derivatives that passes through any given set of data points without spurious oscillations. Local extrema can occur only at grid points where they are given by the data, but not in between two adjacent grid points.”

curveMonotoneY(context)
Source · Produces a cubic spline that preserves monotonicity in x, assuming monotonicity in y, as proposed by Steffen in A simple method for monotonic interpolation in one dimension: “a smooth curve with continuous first-order derivatives that passes through any given set of data points without spurious oscillations. Local extrema can occur only at grid points where they are given by the data, but not in between two adjacent grid points.”

curveNatural(context)
Source · Produces a natural cubic spline with the second derivative of the spline set to zero at the endpoints.

curveStep(context)
Source · Produces a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes at the midpoint of each pair of adjacent x-values.

curveStepAfter(context)
Source · Produces a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes after the x-value.

curveStepBefore(context)
Source · Produces a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes before the x-value.

Custom curves
Curves are typically not used directly, instead being passed to line.curve and area.curve. However, you can define your own curve implementation should none of the built-in curves satisfy your needs using the following interface; see the curveLinear source for an example implementation. You can also use this low-level interface with a built-in curve type as an alternative to the line and area generators.

curve.areaStart()
Indicates the start of a new area segment. Each area segment consists of exactly two line segments: the topline, followed by the baseline, with the baseline points in reverse order.

curve.areaEnd()
Indicates the end of the current area segment.

curve.lineStart()
Indicates the start of a new line segment. Zero or more points will follow.

curve.lineEnd()
Indicates the end of the current line segment.

curve.point(x, y)
Indicates a new point in the current line segment with the given x- and y-values.

---

## Lines

Lines
Examples · The line generator produces a spline or polyline as in a line chart. Lines also appear in many other visualization types, such as the links in hierarchical edge bundling. See also radial lines.

line(x, y)
Source · Constructs a new line generator with the given x and y accessor.

js
const line = d3.line((d) => x(d.Date), (d) => y(d.Close));
If x or y are not specified, the respective defaults will be used. The above can be expressed more explicitly as:

js
const line = d3.line()
    .x((d) => x(d.Date))
    .y((d) => y(d.Close));
line(data)
Source · Generates a line for the given array of data.

js
svg.append("path").attr("d", line(data)).attr("stroke", "currentColor");
If the line generator has a context, then the line is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.

CAUTION

Depending on this line generator’s associated curve, the given input data may need to be sorted by x-value before being passed to the line generator.

line.x(x)
Source · If x is specified, sets the x accessor to the specified function or number and returns this line generator.

js
const line = d3.line().x((d) => x(d.Date));
If x is not specified, returns the current x accessor.

js
line.x() // (d) => x(d.Date)
The x accessor defaults to:

js
function x(d) {
  return d[0];
}
When a line is generated, the x accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.

The default x accessor assumes that the input data are two-element arrays of numbers. If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.

line.y(y)
Source · If y is specified, sets the y accessor to the specified function or number and returns this line generator.

js
const line = d3.line().y((d) => y(d.Close));
When a line is generated, the y accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.

If y is not specified, returns the current y accessor.

js
line.y() // (d) => y(d.Close)
The y accessor defaults to:

js
function y(d) {
  return d[1];
}
The default y accessor assumes that the input data are two-element arrays of numbers. See line.x for more information.

line.defined(defined)
Examples · Source · If defined is specified, sets the defined accessor to the specified function or boolean and returns this line generator.

js
const line = d3.line().defined((d) => !isNaN(d.Close));
When a line is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments. If the given element is defined (i.e., if the defined accessor returns a truthy value for this element), the x and y accessors will subsequently be evaluated and the point will be added to the current line segment. Otherwise, the element will be skipped, the current line segment will be ended, and a new line segment will be generated for the next defined point.

If defined is not specified, returns the current defined accessor.

js
line.defined() // (d) => !isNaN(d.Close)
The defined accessor defaults to the constant true, and assumes that the input data is always defined:

js
function defined() {
  return true;
}
Note that if a line segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps. In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.

line.curve(curve)
Source · If curve is specified, sets the curve factory and returns this line generator.

js
const line = d3.line().curve(d3.curveStep);
If curve is not specified, returns the current curve factory, which defaults to curveLinear.

js
line.curve() // d3.curveStep
line.context(context)
Source · If context is specified, sets the context and returns this line generator.

js
const context = canvas.getContext("2d");
const line = d3.line().context(context);
If context is not specified, returns the current context.

js
line.context() // context
The context defaults to null. If the context is not null, then the generated line is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated line is returned.

line.digits(digits)
Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this line generator.

js
const line = d3.line().digits(3);
If digits is not specified, returns the current maximum fraction digits, which defaults to 3.

js
line.digits() // 3
This option only applies when the associated context is null, as when this line generator is used to produce path data.

---

## Links

Links
Examples · The link shape generates a smooth cubic Bézier curve from a source point to a target point. The tangents of the curve at the start and end are either vertical or horizontal. See also radial links.

link(curve)
Source · Returns a new link generator using the specified curve. For example, to visualize links in a tree diagram rooted on the top edge of the display, you might say:

js
const link = d3.link(d3.curveBumpY)
    .x((d) => d.x)
    .y((d) => d.y);
linkVertical()
Source · Shorthand for link with curveBumpY; suitable for visualizing links in a tree diagram rooted on the top edge of the display. Equivalent to:

js
const link = d3.link(d3.curveBumpY);
linkHorizontal()
Source · Shorthand for link with curveBumpX; suitable for visualizing links in a tree diagram rooted on the left edge of the display. Equivalent to:

js
const link = d3.link(d3.curveBumpX);
link(...arguments)
Source · Generates a link for the given arguments. The arguments are arbitrary; they are propagated to the link generator’s accessor functions along with the this object. With the default settings, an object with source and target properties is expected.

js
link({source: [100, 100], target: [300, 300]}) // "M100,100C200,100,200,300,300,300"
link.source(source)
Source · If source is specified, sets the source accessor to the specified function and returns this link generator.

js
const link = d3.linkHorizontal().source((d) => d[0]);
If source is not specified, returns the current source accessor.

js
link.source() // (d) => d[0]
The source accessor defaults to:

js
function source(d) {
  return d.source;
}
link.target(target)
Source · If target is specified, sets the target accessor to the specified function and returns this link generator.

js
const link = d3.linkHorizontal().target((d) => d[1]);
If target is not specified, returns the current target accessor.

js
link.target() // (d) => d[1]
The target accessor defaults to:

js
function target(d) {
  return d.target;
}
link.x(x)
Source · If x is specified, sets the x-accessor to the specified function or number and returns this link generator.

js
const link = d3.linkHorizontal().x((d) => x(d.x));
If x is not specified, returns the current x accessor.

js
link.x() // (d) => x(d.x)
The x accessor defaults to:

js
function x(d) {
  return d[0];
}
link.y(y)
Source · If y is specified, sets the y-accessor to the specified function or number and returns this link generator.

js
const link = d3.linkHorizontal().y((d) => y(d.y));
If y is not specified, returns the current y accessor.

js
link.y() // (d) => y(d.y)
The y accessor defaults to:

js
function y(d) {
  return d[1];
}
link.context(context)
Source · If context is specified, sets the context and returns this link generator.

js
const context = canvas.getContext("2d");
const link = d3.link().context(context);
If context is not specified, returns the current context.

js
link.context() // context
The context defaults to null. If the context is not null, then the generated link is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated link is returned. See also d3-path.

link.digits(digits)
Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this link generator.

js
const link = d3.link().digits(3);
If digits is not specified, returns the current maximum fraction digits, which defaults to 3.

js
link.digits() // 3
This option only applies when the associated context is null, as when this link generator is used to produce path data.

Pager


---

## Pies

Pies
Examples · The pie generator computes the necessary angles to represent a tabular dataset as a pie or donut chart; these angles can then be passed to an arc generator. (The pie generator does not produce a shape directly.)

pie()
Source · Constructs a new pie generator with the default settings.

js
const pie = d3.pie();
pie(data, ...arguments)
Source · Generates a pie for the given array of data, returning an array of objects representing each datum’s arc angles. For example, given a set of numbers, here is how to compute the angles for a pie chart:

js
const data = [1, 1, 2, 3, 5, 8, 13, 21];
const pie = d3.pie();
const arcs = pie(data);
The resulting arcs is an array of objects:

json
[
  {"data":  1, "value":  1, "index": 6, "startAngle": 6.050474740247008, "endAngle": 6.166830023713296, "padAngle": 0},
  {"data":  1, "value":  1, "index": 7, "startAngle": 6.166830023713296, "endAngle": 6.283185307179584, "padAngle": 0},
  {"data":  2, "value":  2, "index": 5, "startAngle": 5.817764173314431, "endAngle": 6.050474740247008, "padAngle": 0},
  {"data":  3, "value":  3, "index": 4, "startAngle": 5.468698322915565, "endAngle": 5.817764173314431, "padAngle": 0},
  {"data":  5, "value":  5, "index": 3, "startAngle": 4.886921905584122, "endAngle": 5.468698322915565, "padAngle": 0},
  {"data":  8, "value":  8, "index": 2, "startAngle": 3.956079637853813, "endAngle": 4.886921905584122, "padAngle": 0},
  {"data": 13, "value": 13, "index": 1, "startAngle": 2.443460952792061, "endAngle": 3.956079637853813, "padAngle": 0},
  {"data": 21, "value": 21, "index": 0, "startAngle": 0.000000000000000, "endAngle": 2.443460952792061, "padAngle": 0}
]
Each object in the returned array has the following properties:

data - the input datum; the corresponding element in the input data array.
value - the numeric value of the arc.
index - the zero-based sorted index of the arc.
startAngle - the start angle of the arc.
endAngle - the end angle of the arc.
padAngle - the pad angle of the arc.
This representation is designed to work with the arc generator’s default startAngle, endAngle and padAngle accessors. Angles are in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.

The length of the returned array is the same as data, and each element i in the returned array corresponds to the element i in the input data. The returned array of arcs is in the same order as the data, even when the pie chart is sorted.

Any additional arguments are arbitrary; they are propagated to the pie generator’s accessor functions along with the this object.

pie.value(value)
Source · If value is specified, sets the value accessor to the specified function or number and returns this pie generator.

js
const pie = d3.pie().value((d) => d.value);
When a pie is generated, the value accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments.

If value is not specified, returns the current value accessor.

js
pie.value() // (d) => d.value
The value accessor defaults to:

js
function value(d) {
  return d;
}
The default value accessor assumes that the input data are numbers, or that they are coercible to numbers using valueOf. If your data are not numbers, then you should specify an accessor that returns the corresponding numeric value for a given datum. For example, given a CSV file with number and name fields:


number,name
4,Locke
8,Reyes
15,Ford
16,Jarrah
23,Shephard
42,Kwon
You might say:

js
const data = await d3.csv("lost.csv", d3.autoType);
const pie = d3.pie().value((d) => d.number);
const arcs = pie(data);
This is similar to mapping your data to values before invoking the pie generator:

js
const arcs = d3.pie()(data.map((d) => d.number));
The benefit of an accessor is that the input data remains associated with the returned objects, thereby making it easier to access other fields of the data, for example to set the color or to add text labels.

pie.sort(compare)
Source · If compare is specified, sets the data comparator to the specified function and returns this pie generator.

js
const pie = d3.pie().sort((a, b) => d3.ascending(a.name, b.name));
The data comparator takes two arguments a and b, each elements from the input data array. If the arc for a should be before the arc for b, then the comparator must return a number less than zero; if the arc for a should be after the arc for b, then the comparator must return a number greater than zero; returning zero means that the relative order of a and b is unspecified.

If compare is not specified, returns the current data comparator.

js
pie.sort() // (a, b) => d3.ascending(a.name, b.name))
The data comparator defaults to null. If both the data comparator and the value comparator are null, then arcs are positioned in the original input order. Setting the data comparator implicitly sets the value comparator to null.

Sorting does not affect the order of the generated arc array which is always in the same order as the input data array; it only affects the computed angles of each arc. The first arc starts at the start angle and the last arc ends at the end angle.

pie.sortValues(compare)
Source · If compare is specified, sets the value comparator to the specified function and returns this pie generator.

js
const pie = d3.pie().sortValues(d3.ascending);
The value comparator is similar to the data comparator, except the two arguments a and b are values derived from the input data array using the value accessor rather than the data elements. If the arc for a should be before the arc for b, then the comparator must return a number less than zero; if the arc for a should be after the arc for b, then the comparator must return a number greater than zero; returning zero means that the relative order of a and b is unspecified.

If compare is not specified, returns the current value comparator.

js
pie.sortValues() // d3.ascending
The value comparator defaults to descending. If both the data comparator and the value comparator are null, then arcs are positioned in the original input order. Setting the value comparator implicitly sets the data comparator to null.

Sorting does not affect the order of the generated arc array which is always in the same order as the input data array; it merely affects the computed angles of each arc. The first arc starts at the start angle and the last arc ends at the end angle.

pie.startAngle(angle)
Source · If angle is specified, sets the overall start angle of the pie to the specified function or number and returns this pie generator.

js
const pie = d3.pie().startAngle(0);
The start angle is the overall start angle of the pie, i.e., the start angle of the first arc. It is typically expressed as a constant number but can also be expressed as a function of data. When a function, the start angle accessor is invoked once, being passed the same arguments and this context as the pie generator.

If angle is not specified, returns the current start angle accessor.

js
pie.startAngle() // () => 0
The start angle accessor defaults to:

js
function startAngle() {
  return 0;
}
Angles are in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.

pie.endAngle(angle)
Source · If angle is specified, sets the overall end angle of the pie to the specified function or number and returns this pie generator.

js
const pie = d3.pie().endAngle(Math.PI);
The end angle here means the overall end angle of the pie, i.e., the end angle of the last arc. It is typically expressed as a constant number but can also be expressed as a function of data. When a function, the end angle accessor is invoked once, being passed the same arguments and this context as the pie generator.

If angle is not specified, returns the current end angle accessor.

js
pie.endAngle() // () => Math.PI
The end angle accessor defaults to:

js
function endAngle() {
  return 2 * Math.PI;
}
Angles are in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise. The value of the end angle is constrained to startAngle ± τ, such that |endAngle - startAngle| ≤ τ.

pie.padAngle(angle)
Pad angle:

0.030

Examples · Source · If angle is specified, sets the pad angle to the specified function or number and returns this pie generator.

js
const pie = d3.pie().padAngle(0.03);
The pad angle specifies the angular separation in radians between adjacent arcs. The total amount of padding is the specified angle times the number of elements in the input data array, and at most |endAngle - startAngle|; the remaining space is divided proportionally by value such that the relative area of each arc is preserved.

The pad angle is typically expressed as a constant number but can also be expressed as a function of data. When a function, the pad angle accessor is invoked once, being passed the same arguments and this context as the pie generator.

If angle is not specified, returns the current pad angle accessor.

js
pie.padAngle() // () => 0.03
The pad angle accessor defaults to:

js
function padAngle() {
  return 0;
}
Pager


---

## Stacks

Stacks
Examples · Stacking converts lengths into contiguous position intervals. For example, a bar chart of monthly sales might be broken down into a multi-series bar chart by category, stacking bars vertically and applying a categorical color encoding. Stacked charts can show overall value and per-category value simultaneously; however, it is typically harder to compare across categories as only the bottom layer of the stack is aligned. So, chose the stack order carefully, and consider a streamgraph. (See also grouped charts.)

Like the pie generator, the stack generator does not produce a shape directly. Instead it computes positions which you can then pass to an area generator or use directly, say to position bars.

stack()
Source · Constructs a new stack generator with the default settings. See stack for usage.

stack(data, ...arguments)
Source · Generates a stack for the given array of data and returns an array representing each series. Any additional arguments are arbitrary; they are propagated to accessors along with the this object.

For example, consider this tidy table of monthly fruit sales:

date	fruit	sales
1/2015	apples	3840
1/2015	bananas	1920
1/2015	cherries	960
1/2015	durians	400
2/2015	apples	1600
2/2015	bananas	1440
2/2015	cherries	960
2/2015	durians	400
3/2015	apples	640
3/2015	bananas	960
3/2015	cherries	640
3/2015	durians	400
4/2015	apples	320
4/2015	bananas	480
4/2015	cherries	640
4/2015	durians	400
This could be represented in JavaScript as an array of objects, perhaps parsed from CSV:

js
const data = [
  {date: new Date("2015-01-01"), fruit: "apples", sales: 3840},
  {date: new Date("2015-01-01"), fruit: "bananas", sales: 1920},
  {date: new Date("2015-01-01"), fruit: "cherries", sales: 960},
  {date: new Date("2015-01-01"), fruit: "durians", sales: 400},
  {date: new Date("2015-02-01"), fruit: "apples", sales: 1600},
  {date: new Date("2015-02-01"), fruit: "bananas", sales: 1440},
  {date: new Date("2015-02-01"), fruit: "cherries", sales: 960},
  {date: new Date("2015-02-01"), fruit: "durians", sales: 400},
  {date: new Date("2015-03-01"), fruit: "apples", sales: 640},
  {date: new Date("2015-03-01"), fruit: "bananas", sales: 960},
  {date: new Date("2015-03-01"), fruit: "cherries", sales: 640},
  {date: new Date("2015-03-01"), fruit: "durians", sales: 400},
  {date: new Date("2015-04-01"), fruit: "apples", sales: 320},
  {date: new Date("2015-04-01"), fruit: "bananas", sales: 480},
  {date: new Date("2015-04-01"), fruit: "cherries", sales: 640},
  {date: new Date("2015-04-01"), fruit: "durians", sales: 400}
];
To compute the stacked series (a series, or layer, for each fruit; and a stack, or column, for each date), we can index the data by date and then fruit, compute the distinct fruit names across the data set, and lastly get the sales value for each date and fruit.

js
const series = d3.stack()
    .keys(d3.union(data.map(d => d.fruit))) // apples, bananas, cherries, …
    .value(([, group], key) => group.get(key).sales)
  (d3.index(data, d => d.date, d => d.fruit));
TIP

See union and index from d3-array.

The resulting array has one element per series. Each series has one point per month, and each point has a lower and upper value defining the baseline and topline:

js
[
  [[   0, 3840], [   0, 1600], [   0,  640], [   0,  320]], // apples
  [[3840, 5760], [1600, 3040], [ 640, 1600], [ 320,  800]], // bananas
  [[5760, 6720], [3040, 4000], [1600, 2240], [ 800, 1440]], // cherries
  [[6720, 7120], [4000, 4400], [2240, 2640], [1440, 1840]]  // durians
]
Each series in then typically passed to an area generator to render an area chart, or used to construct rectangles for a bar chart.

js
svg.append("g")
  .selectAll("g")
  .data(series)
  .join("g")
    .attr("fill", d => color(d.key))
  .selectAll("rect")
  .data(D => D)
  .join("rect")
    .attr("x", d => x(d.data[0]))
    .attr("y", d => y(d[1]))
    .attr("height", d => y(d[0]) - y(d[1]))
    .attr("width", x.bandwidth());
The series are determined by the keys accessor; each series i in the returned array corresponds to the ith key. Each series is an array of points, where each point j corresponds to the jth element in the input data. Lastly, each point is represented as an array [y0, y1] where y0 is the lower value (baseline) and y1 is the upper value (topline); the difference between y0 and y1 corresponds to the computed value for this point. The key for each series is available as series.key, and the index as series.index. The input data element for each point is available as point.data.

stack.keys(keys)
Source · If keys is specified, sets the keys accessor to the specified function or array and returns this stack generator.

js
const stack = d3.stack().keys(["apples", "bananas", "cherries", "durians"]);
If keys is not specified, returns the current keys accessor.

js
stack.keys() // () => ["apples", "bananas", "cherries", "durians"]
The keys accessor defaults to the empty array. A series (layer) is generated for each key. Keys are typically strings, but they may be arbitrary values; see InternMap. The series’ key is passed to the value accessor, along with each data point, to compute the point’s value.

stack.value(value)
Source · If value is specified, sets the value accessor to the specified function or number and returns this stack generator.

js
const stack = d3.stack().value((d, key) => d[key]);
If value is not specified, returns the current value accessor.

js
stack.value() // (d, key) => d[key]
The value accessor defaults to:

js
function value(d, key) {
  return d[key];
}
CAUTION

The default value accessor assumes that the input data is an array of objects exposing named properties with numeric values. This is a “wide” rather than “tidy” representation of data and is no longer recommended. See stack for an example using tidy data.

stack.order(order)
Source · If order is specified, sets the order accessor to the specified function or array and returns this stack generator.

js
const stack = d3.stack().order(d3.stackOrderNone);
If order is a function, it is passed the generated series array and must return an array of numeric indexes representing the stack order. For example, to use reverse key order:

js
const stack = d3.stack().order(series => d3.range(series.length).reverse());
The stack order is computed prior to the offset; thus, the lower value for all points is zero at the time the order is computed. The index attribute for each series is also not set until after the order is computed.

If order is not specified, returns the current order accessor.

js
stack.order() // d3.stackOrderNone
The order accessor defaults to stackOrderNone; this uses the order given by the key accessor. See stack orders for the built-in orders.

stack.offset(offset)
Source · If offset is specified, sets the offset accessor to the specified function and returns this stack generator.

js
const stack = d3.stack().offset(d3.stackOffsetExpand);
The offset function is passed the generated series array and the order index array; it is then responsible for updating the lower and upper values in the series array. See the built-in offsets for a reference implementation.

If offset is not specified, returns the current offset acccesor.

js
stack.offset() // d3.stackOffsetExpand
The offset accessor defaults to stackOffsetNone; this uses a zero baseline. See stack offsets for the built-in offsets.

Stack orders
Stack orders are typically not used directly, but are instead passed to stack.order.

stackOrderAppearance(series)
0
5
10
15
20
↑ Annual revenue (billions)
1975
1980
1985
1990
1995
2000
2005
2010
2015
js
const stack = d3.stack().order(d3.stackOrderAppearance);
Source · Returns a series order such that the earliest series (according to the maximum value) is at the bottom.

stackOrderAscending(series)
0
5
10
15
20
↑ Annual revenue (billions)
1975
1980
1985
1990
1995
2000
2005
2010
2015
js
const stack = d3.stack().order(d3.stackOrderAscending);
Source · Returns a series order such that the smallest series (according to the sum of values) is at the bottom.

stackOrderDescending(series)
0
5
10
15
20
↑ Annual revenue (billions)
1975
1980
1985
1990
1995
2000
2005
2010
2015
js
const stack = d3.stack().order(d3.stackOrderDescending);
Source · Returns a series order such that the largest series (according to the sum of values) is at the bottom.

stackOrderInsideOut(series)
0
5
10
15
20
25
↑ Annual revenue (billions)
1975
1980
1985
1990
1995
2000
2005
2010
2015
js
const stack = d3.stack().order(d3.stackOrderInsideOut);
Source · Returns a series order such that the earliest series (according to the maximum value) are on the inside and the later series are on the outside. This order is recommended for streamgraphs in conjunction with the wiggle offset. See Stacked Graphs — Geometry & Aesthetics by Byron & Wattenberg for more information.

stackOrderNone(series)
0
5
10
15
20
↑ Annual revenue (billions)
1975
1980
1985
1990
1995
2000
2005
2010
2015
js
const stack = d3.stack().order(d3.stackOrderNone);
Source · Returns the given series order [0, 1, … n - 1] where n is the number of elements in series. Thus, the stack order is given by the key accessor.

stackOrderReverse(series)
0
5
10
15
20
↑ Annual revenue (billions)
1975
1980
1985
1990
1995
2000
2005
2010
2015
js
const stack = d3.stack().order(d3.stackOrderReverse);
Source · Returns the reverse of the given series order [n - 1, n - 2, … 0] where n is the number of elements in series. Thus, the stack order is given by the reverse of the key accessor.

Stack offsets
Stack offsets are typically not used directly, but are instead passed to stack.offset.

stackOffsetExpand(series, order)
0
20
40
60
80
100
↑ Annual revenue (%)
1975
1980
1985
1990
1995
2000
2005
2010
2015
js
const stack = d3.stack().offset(d3.stackOffsetExpand);
Source · Applies a zero baseline and normalizes the values for each point such that the topline is always one.

stackOffsetDiverging(series, order)
−20
−10
0
10
↑ Annual revenue (billions)
1975
1980
1985
1990
1995
2000
2005
2010
2015
js
const stack = d3.stack().offset(d3.stackOffsetDiverging);
Source · Positive values are stacked above zero, negative values are stacked below zero, and zero values are stacked at zero.

stackOffsetNone(series, order)
0
5
10
15
20
↑ Annual revenue (billions)
1975
1980
1985
1990
1995
2000
2005
2010
2015
js
const stack = d3.stack().offset(d3.stackOffsetNone);
Source · Applies a zero baseline.

stackOffsetSilhouette(series, order)
0
5
10
15
20
↑ Annual revenue (billions)
1975
1980
1985
1990
1995
2000
2005
2010
2015
js
const stack = d3.stack().offset(d3.stackOffsetSilhouette);
Source · Shifts the baseline down such that the center of the streamgraph is always at zero.

stackOffsetWiggle(series, order)
0
5
10
15
20
25
↑ Annual revenue (billions)
1975
1980
1985
1990
1995
2000
2005
2010
2015
js
const stack = d3.stack().offset(d3.stackOffsetWiggle);
Source · Shifts the baseline so as to minimize the weighted wiggle of layers. This offset is recommended for streamgraphs in conjunction with the inside-out order. See Stacked Graphs — Geometry & Aesthetics by Bryon & Wattenberg for more information.

---

## Symbols

Symbols
Examples · Symbols provide a categorical shape encoding as in a scatterplot. Symbols are centered at the origin; use a transform to move the symbol to a different position.

symbol(type, size)
Source · Constructs a new symbol generator of the specified type and size. If not specified, type defaults to a circle, and size defaults to 64.

js
svg.append("path").attr("d", d3.symbol(d3.symbolCross));
symbol(...arguments)
Source · Generates a symbol for the given arguments. The arguments are arbitrary; they are propagated to the symbol generator’s accessor functions along with the this object. With the default settings, invoking the symbol generator produces a circle of 64 square pixels.

js
d3.symbol()() // "M4.514,0A4.514,4.514,0,1,1,-4.514,0A4.514,4.514,0,1,1,4.514,0"
If the symbol generator has a context, then the symbol is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.

symbol.type(type)
Source · If type is specified, sets the symbol type to the specified function or symbol type and returns this symbol generator.

js
const symbol = d3.symbol().type(d3.symbolCross);
If type is a function, the symbol generator’s arguments and this are passed through. This is convenient for use with selection.attr, say in conjunction with an ordinal scale to produce a categorical symbol encoding.

js
const symbolType = d3.scaleOrdinal(d3.symbolsFill);
const symbol = d3.symbol().type((d) => symbolType(d.category));
If type is not specified, returns the current symbol type accessor.

js
symbol.type() // () => d3.symbolCross
The symbol type accessor defaults to:

js
function type() {
  return circle;
}
See symbolsFill and symbolsStroke for built-in symbol types. To implement a custom symbol type, pass an object that implements symbolType.draw.

symbol.size(size)
Source · If size is specified, sets the size to the specified function or number and returns this symbol generator.

js
const symbol = d3.symbol().size(100);
If size is a function, the symbol generator’s arguments and this are passed through. This is convenient for use with selection.attr, say in conjunction with a linear scale to produce a quantitative size encoding.

js
const symbolSize = d3.scaleLinear([0, 100]);
const symbol = d3.symbol().size((d) => symbolSize(d.value));
If size is not specified, returns the current size accessor.

js
symbol.size() // () => 100
The size accessor defaults to:

js
function size() {
  return 64;
}
symbol.context(context)
Source · If context is specified, sets the context and returns this symbol generator.

js
const context = canvas.getContext("2d");
const symbol = d3.symbol().context(context);
If context is not specified, returns the current context.

js
symbol.context() // context
The context defaults to null. If the context is not null, then the generated symbol is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated symbol is returned.

symbol.digits(digits)
Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this symbol generator.

js
const symbol = d3.symbol().digits(3);
If digits is not specified, returns the current maximum fraction digits, which defaults to 3.

js
symbol.digits() // 3
This option only applies when the associated context is null, as when this symbol generator is used to produce path data.

symbolsFill
circle
cross
diamond
square
star
triangle
wye
Source · An array containing a set of symbol types designed for filling: circle, cross, diamond, square, star, triangle, and wye. Useful for a categorical shape encoding with an ordinal scale.

js
const symbolType = d3.scaleOrdinal(d3.symbolsFill);
symbolsStroke
asterisk
circle
diamond2
plus
square2
times
triangle2
Source · An array containing a set of symbol types designed for stroking: circle, plus, times, triangle2, asterisk, square2, and diamond2. Useful for a categorical shape encoding with an ordinal scale.

js
const symbolType = d3.scaleOrdinal(d3.symbolsStroke);
symbolAsterisk
Source · The asterisk symbol type; intended for stroking.

symbolCircle
Source · The circle symbol type; intended for either filling or stroking.

symbolCross
Source · The Greek cross symbol type, with arms of equal length; intended for filling.

symbolDiamond
Source · The rhombus symbol type; intended for filling.

symbolDiamond2
Source · The rotated square symbol type; intended for stroking.

symbolPlus
Source · The plus symbol type; intended for stroking.

symbolSquare
Source · The square symbol type; intended for filling.

symbolSquare2
Source · The square2 symbol type; intended for stroking.

symbolStar
Source · The pentagonal star (pentagram) symbol type; intended for filling.

symbolTriangle
Source · The up-pointing triangle symbol type; intended for filling.

symbolTriangle2
Source · The up-pointing triangle symbol type; intended for stroking.

symbolWye
Source · The Y-shape symbol type; intended for filling.

symbolTimes
Source · The X-shape symbol type; intended for stroking.

Custom symbols
Symbol types are typically not used directly, instead being passed to symbol.type. However, you can define your own symbol type implementation should none of the built-in types satisfy your needs using the following interface. You can also use this low-level interface with a built-in symbol type as an alternative to the symbol generator.

js
const path = d3.pathRound(3);
const circle = d3.symbolCircle.draw(path, 64);
path.toString(); // "M4.514,0A4.514,4.514,0,1,1,-4.514,0A4.514,4.514,0,1,1,4.514,0"
symbolType.draw(context, size)
Renders this symbol type to the specified context with the specified size in square pixels. The context implements the CanvasPathMethods interface. (Note that this is a subset of the CanvasRenderingContext2D interface!) See also d3-path.

pointRadial(angle, radius)
Examples · Source · Returns the point [x, y] for the given angle in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise, and the given radius.

js
d3.pointRadial(Math.PI / 3, 100) // [86.60254037844386, -50]

---

## Radial Areas

Radial areas
Examples · A radial area generator is like the Cartesian area generator except the x and y accessors are replaced with angle and radius accessors. Radial areas are positioned relative to the origin; use a transform to change the origin.

areaRadial()
Source · Constructs a new radial area generator with the default settings.

js
const area = d3.areaRadial();
areaRadial(data)
Source · Equivalent to area.

js
svg.append("path").attr("d", area(data));
areaRadial.angle(angle)
Source · Equivalent to area.x, except the accessor returns the angle in radians, with 0 at -y (12 o’clock).

js
const area = d3.areaRadial().angle((d) => a(d.Date));
areaRadial.startAngle(angle)
Source · Equivalent to area.x0, except the accessor returns the angle in radians, with 0 at -y (12 o’clock). Note: typically angle is used instead of setting separate start and end angles.

areaRadial.endAngle(angle)
Source · Equivalent to area.x1, except the accessor returns the angle in radians, with 0 at -y (12 o’clock). Note: typically angle is used instead of setting separate start and end angles.

areaRadial.radius(radius)
Source · Equivalent to area.y, except the accessor returns the radius: the distance from the origin.

js
const area = d3.areaRadial().radius((d) => r(d.temperature));
areaRadial.innerRadius(radius)
Source · Equivalent to area.y0, except the accessor returns the radius: the distance from the origin.

js
const area = d3.areaRadial().radius((d) => r(d.low));
areaRadial.outerRadius(radius)
Source · Equivalent to area.y1, except the accessor returns the radius: the distance from the origin.

js
const area = d3.areaRadial().radius((d) => r(d.high));
areaRadial.defined(defined)
Source · Equivalent to area.defined.

js
const area = d3.areaRadial().defined((d) => !isNaN(d.temperature));
areaRadial.curve(curve)
Source · Equivalent to area.curve. Note that curveMonotoneX or curveMonotoneY are not recommended for radial areas because they assume that the data is monotonic in x or y, which is typically untrue of radial areas.

js
const area = d3.areaRadial().curve(d3.curveBasisClosed);
areaRadial.context(context)
Source · Equivalent to area.context.

js
const context = canvas.getContext("2d");
const area = d3.areaRadial().context(context);
areaRadial.lineInnerRadius()
An alias for areaRadial.lineStartAngle.

areaRadial.lineStartAngle()
Source · Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context. The line’s angle accessor is this area’s start angle accessor, and the line’s radius accessor is this area’s inner radius accessor.

areaRadial.lineEndAngle()
Source · Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context. The line’s angle accessor is this area’s end angle accessor, and the line’s radius accessor is this area’s inner radius accessor.

areaRadial.lineOuterRadius()
Source · Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context. The line’s angle accessor is this area’s start angle accessor, and the line’s radius accessor is this area’s outer radius accessor.

---

## Radial Lines

Radial lines
Examples · A radial line generator is like the Cartesian line generator except the x and y accessors are replaced with angle and radius accessors. Radial lines are positioned relative to the origin; use a transform to change the origin.

lineRadial()
Source · Constructs a new radial line generator with the default settings.

js
const line = d3.lineRadial();
lineRadial(data)
Source · Equivalent to line.

js
svg.append("path").attr("d", line(data)).attr("stroke", "currentColor");
lineRadial.angle(angle)
Source · Equivalent to line.x, except the accessor returns the angle in radians, with 0 at -y (12 o’clock).

js
const line = d3.lineRadial().angle((d) => a(d.Date));
lineRadial.radius(radius)
Source · Equivalent to line.y, except the accessor returns the radius: the distance from the origin.

js
const line = d3.lineRadial().radius((d) => r(d.temperature));
lineRadial.defined(defined)
Source · Equivalent to line.defined.

js
const line = d3.lineRadial().defined((d) => !isNaN(d.temperature));
lineRadial.curve(curve)
Source · Equivalent to line.curve. Note that curveMonotoneX or curveMonotoneY are not recommended for radial lines because they assume that the data is monotonic in x or y, which is typically untrue of radial lines.

js
const line = d3.lineRadial().curve(d3.curveBasis);
lineRadial.context(context)
Source · Equivalent to line.context.

js
const context = canvas.getContext("2d");
const line = d3.lineRadial().context(context);

---

## Radial Links

Radial links
A radial link generator is like the Cartesian link generator except the x and y accessors are replaced with angle and radius accessors. Radial links are positioned relative to the origin; use a transform to change the origin.

linkRadial()
Source · Returns a new link generator with radial tangents. For example, to visualize links in a tree diagram rooted in the center of the display, you might say:

js
const link = d3.linkRadial()
    .angle((d) => d.x)
    .radius((d) => d.y);
linkRadial.angle(angle)
Source · Equivalent to link.x, except the accessor returns the angle in radians, with 0 at -y (12 o’clock).

linkRadial.radius(radius)
Source · Equivalent to link.y, except the accessor returns the radius: the distance from the origin.