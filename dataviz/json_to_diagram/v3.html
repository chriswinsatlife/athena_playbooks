<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
    <meta title="V3 - Monochrome" />
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    svg {
      width: 100%;
      height: 100%;
      display: block;
      background: #fff;
    }
/* Master node rectangle styles (applies to all levels if not overridden) */
.node rect {
  fill: #f0f0f0;
  stroke: #bbb;
  stroke-width: 0px;
  rx: 8;
  ry: 8;
}

/* Master text/foreignObject styles */
.node text,
.node-fo > div {
  font-family: sans-serif;
  font-size: 14px;
  color: #333;
  text-align: center;
  line-height: 1.2em;
}

/* If you’re using <text> elements (not foreignObject) and want precise centering: */
.node text {
  text-anchor: middle;
  dominant-baseline: middle;
}

/* If you’re using foreignObject: center the div flexbox-style */
.node-fo > div {
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  padding: 6px;
}

/* Master link styles */
.link {
  fill: none;
  stroke: #bbb;
  stroke-width: 1px;
}

/* LEVEL-SPECIFIC OVERRIDES (levels 1..5) */

/* Level 1 */
.node-level1 rect {
  fill: #000;
  stroke: #000;
}
.node-level1 text,
.node-level1 .node-fo > div {
  color: #fff;
}
.link-level1 {
  stroke: #666;
}

/* Level 2 */
.node-level2 rect {
  fill: #f2649c;
  stroke: #e65088;
}
.node-level2 text,
.node-level2 .node-fo > div {
  color: #fff;
}
.link-level2 {
  stroke: #999;
}

/* Level 3 */
.node-level3 rect {
  fill: #fafafa;
  stroke: #ccc;
}
.node-level3 text,
.node-level3 .node-fo > div {
  color: #333;
}
.link-level3 {
  stroke: #999;
}

/* Level 4 */
.node-level4 rect {
  fill: #f2f2ff;
  stroke: #ccc;
}
.node-level4 text,
.node-level4 .node-fo > div {
  color: #333;
  text-align: left; /* example override if needed */
}
.link-level4 {
  stroke: #aaa;
}

/* Level 5 */
.node-level5 rect {
  fill: #fff0f5;
  stroke: #ccc;
}
.node-level5 text,
.node-level5 .node-fo > div {
  color: #333;
  text-align: left;
}
.link-level5 {
  stroke: #aaa;
}

/* Up to 10 items in Level 2 */
.level2-item1 rect { fill: #6e87ff; stroke: #4660b8; stroke-width: 0px }
.level2-item2 rect { fill: #ad6cff; stroke: #7a3dcc; stroke-width: 0px }
.level2-item3 rect { fill: #ff8150; stroke: #cc501e; stroke-width: 0px }
.level2-item4 rect { fill: #ffbd50; stroke: #cc8d1e; stroke-width: 0px }
.level2-item5 rect { fill: #51e1a8; stroke: #38b080; stroke-width: 0px }
.level2-item6 rect { fill: #ffdceb; stroke: #ffa2ca; stroke-width: 0px }
.level2-item7 rect { fill: #ffee55; stroke: #ccbb11; stroke-width: 0px }
.level2-item8 rect { fill: #cccccc; stroke: #999999; stroke-width: 0px }
.level2-item9 rect { fill: #c2ffd6; stroke: #68cc8f; stroke-width: 0px }
.level2-item10 rect { fill: #f2649c; stroke: #e65088; stroke-width: 0px }
</style>

</head>

<body>

<svg id="mindmap"></svg>

<script>
const data = {
  name: "Improving Your Product Sense Course",
  children: [
    {
      name: "Motivation Theory",
      children: [
        { name: "Motivation" },
        { name: "Friction" },
        { name: "Satisfaction" },
        { name: "Nudge" }
      ]
    },
    {
      name: "Cognitive Empathy",
      children: [
        { name: "Metacognition" },
        { name: "Intellectual Flexibility" },
        { name: "Simulation" }
      ]
    },
    {
      name: "Creativity",
      children: [
        {
          name: "Strategic Thinking",
          children: [
            { name: "Positioning" },
            { name: "Segmentation" },
            { name: "Differentiation" },
            { name: "Core of Product Strategy" }
          ]
        },
        {
          name: "Creative Execution",
          children: [
            { name: "Creative Mindset" },
            { name: "Team Rituals" },
            { name: "Product Creativity Techniques" }
          ]
        }
      ]
    },
    {
      name: "Domain Expertise",
      children: [
        { name: "Very specific - [Tackle Qs in AMAs]" }
      ]
    }
  ]
};

const root = d3.hierarchy(data);
const hiddenMeasure = document.createElement("div");
hiddenMeasure.style.position = "absolute";
hiddenMeasure.style.visibility = "hidden";
hiddenMeasure.style.width = "auto";
hiddenMeasure.style.whiteSpace = "normal";
hiddenMeasure.style.wordWrap = "break-word";
hiddenMeasure.style.font = "14px sans-serif";
hiddenMeasure.style.lineHeight = "1.3em";
document.body.appendChild(hiddenMeasure);

function measureWrapped(txt, widthPx){
  hiddenMeasure.style.width = widthPx + "px";
  hiddenMeasure.innerText = txt;
  return hiddenMeasure.scrollHeight;
}

function rectWidth(d){
  switch(d.depth){
    case 0: return 220;
    case 1: return 180;
    case 2: return 160;
    default: return 140;
  }
}

root.each(d => {
  const w = rectWidth(d);
  const sidePad = 12;
  const tH = measureWrapped(d.data.name, w - sidePad);
  d.data.nodeHeight = tH + 12;
});

const siblingSpacing = 20;
const groupSpacing   = 60;
const horizontalSpacing = 320;

function isGroup(n){ return n.children && n.children.length>0; }

function computeSubtreeHeight(node){
  const h = node.data.nodeHeight;
  if(!isGroup(node)){
    node.data.subtreeHeight = h;
    return h;
  }
  let sum = 0;
  for(let i=0; i<node.children.length; i++){
    const c = node.children[i];
    const ch = computeSubtreeHeight(c);
    sum += ch;
    if(i < node.children.length -1){
      const nxt = node.children[i+1];
      sum += (isGroup(c)||isGroup(nxt)) ? groupSpacing : siblingSpacing;
    }
  }
  node.data.subtreeHeight = Math.max(h, sum);
  return node.data.subtreeHeight;
}
computeSubtreeHeight(root);

function layoutTree(node, depth, topY){
  if(!isGroup(node)){
    node.x = depth * horizontalSpacing;
    node.y = topY + node.data.nodeHeight/2;
    return node.data.nodeHeight;
  }
  node.x = depth * horizontalSpacing;
  let childHeights = [];
  node.children.forEach(c => {
    childHeights.push(computeSubtreeHeight(c));
  });
  let sumKids = 0;
  node.children.forEach((c,i)=>{
    sumKids += c.data.subtreeHeight;
    if(i < node.children.length-1){
      let nxt = node.children[i+1];
      sumKids += (isGroup(c)||isGroup(nxt)) ? groupSpacing : siblingSpacing;
    }
  });
  node.data.subtreeHeight = Math.max(node.data.nodeHeight, sumKids);
  node.x = depth * horizontalSpacing;
  node.y = topY + node.data.subtreeHeight/2;
  let extra = node.data.subtreeHeight - sumKids;
  let childTop = topY + extra/2;
  node.children.forEach((c,i)=>{
    layoutTree(c, depth+1, childTop);
    childTop += c.data.subtreeHeight;
    if(i<node.children.length-1){
      let nxt = node.children[i+1];
      childTop += (isGroup(c)||isGroup(nxt)) ? groupSpacing : siblingSpacing;
    }
  });
  return node.data.subtreeHeight;
}
layoutTree(root, 0, 0);

const svg = d3.select("#mindmap");
const gAll = svg.append("g").attr("class","everything");
const nodes = root.descendants();
const links = root.links();

function curlyBrace(px, py, cx, cy){
  const mid = (px + cx)/2;
  return `M${px},${py}C${mid},${py} ${mid},${cy} ${cx},${cy}`;
}
function leftEdge(d){ return d.x - rectWidth(d)/2; }
function rightEdge(d){return d.x + rectWidth(d)/2; }

gAll.selectAll("path.link")
  .data(links)
  .join("path")
  .attr("class", d => `link level${d.target.depth}-link`)
  .attr("d", d => {
    const sx = rightEdge(d.source);
    const sy = d.source.y;
    const tx = leftEdge(d.target);
    const ty = d.target.y;
    return curlyBrace(sx, sy, tx, ty);
  });

const nodeG = gAll.selectAll("g.node")
  .data(nodes)
  .join("g")
  .attr("class", d => `node level${d.depth}-node`)
  .attr("transform", d => `translate(${d.x},${d.y})`);

nodeG.append("rect")
  .each(function(d){
    const w = rectWidth(d);
    const h = d.data.nodeHeight;
    d3.select(this)
      .attr("x", -w/2)
      .attr("y", -h/2)
      .attr("width", w)
      .attr("height", h);
  });

nodeG.append("foreignObject")
  .attr("class","node-fo")
  .each(function(d){
    const w = rectWidth(d);
    const h = d.data.nodeHeight;
    d3.select(this)
      .attr("x", -w/2)
      .attr("y", -h/2)
      .attr("width", w)
      .attr("height", h)
      .append("xhtml:div")
      .html(d.data.name);
  });

const bbox = gAll.node().getBBox();
const margin = 50;
svg.attr("viewBox",[bbox.x - margin,bbox.y - margin,bbox.width + margin*2,bbox.height + margin*2]);
</script>

</body>


</html>

